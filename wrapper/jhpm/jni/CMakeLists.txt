CMAKE_MINIMUM_REQUIRED(VERSION 3.4.3)

# Requires JNI module.
FIND_PACKAGE(JNI REQUIRED)

# Build shared/dynamic library option
OPTION(BUILD_SHARED_LIBS "Build package with shared libraries." ON)
OPTION(BUILD_WITH_EXTERNAL_PROJECT "Enable external project build." ON)
OPTION(BUILD_WITH_INSTALL "" ON )
IF(NOT BUILD_SHARED_LIBS)
	SET(CMAKE_EXE_LINKER_FLAGS "-static")
	SET(LINK_SEARCH_START_STATIC TRUE)
ENDIF()

# gcc compiler options.
IF((CMAKE_COMPILER_IS_GNUCC) AND NOT CMAKE_COMPILER_IS_MINGOW)
	IF(BUILD_SHARED_LIBS AND CMAKE_SIZEOF_VOID_P EQUAL 8)
		ADD_DEFINITIONS(-fPIC)
		SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC")
	ENDIF()

	# Compiling language standard.
	ADD_DEFINITIONS(-std=c11)
	ADD_DEFINITIONS(-I${JAVA_INCLUDE_PATH})
	ADD_DEFINITIONS(-I${JAVA_INCLUDE_PATH2})
	ADD_DEFINITIONS(-Wl,--add-stdcall-alias)
	ADD_DEFINITIONS(-Werror)

	# Check build target.
	IF (CMAKE_BUILD_TYPE STREQUAL "Release")
		MESSAGE(STATUS "Compile for release.")
		ADD_DEFINITIONS(-DNDEBUG -O2)
		SET(CMAKE_RELEASE TRUE)
	ELSEIF( CMAKE_BUILD_TYPE STREQUAL "Debug")
		MESSAGE(STATUS "Compile for debug.")
		ADD_DEFINITIONS(-D_DEBUG)
		ADD_DEFINITIONS(-g3 -O0)
		SET(CMAKE_DEBUG TRUE)
	ENDIF()

ELSEIF(MSVC)

	# Enable multi-core complication with MSVC
	ADD_DEFINITIONS(/MP)
ENDIF()

FIND_PACKAGE(Git)
IF(GIT_FOUND)
	MESSAGE(STATUS "git found: ${GIT_EXECUTABLE} -- ${GIT_VERSION_STRING}")
ENDIF()
IF(GIT_FOUND AND EXISTS "${PROJECT_SOURCE_DIR}/.git")
	# Update submodules as needed
	OPTION(GIT_SUBMODULE "Check submodules during build" ON)
	IF(GIT_SUBMODULE)
		MESSAGE(STATUS "Submodule update")
		EXECUTE_PROCESS(COMMAND ${GIT_EXECUTABLE} submodule update --init
						WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
						RESULT_VARIABLE GIT_SUBMOD_RESULT)
		IF(NOT GIT_SUBMOD_RESULT EQUAL "0")
			MESSAGE(FATAL_ERROR "git submodule update --init failed with ${GIT_SUBMOD_RESULT}, please checkout submodules")
		ENDIF()
	ENDIF()
ELSE()

ENDIF()

IF (BUILD_WITH_EXTERNAL_PROJECT)
	INCLUDE(ExternalProject)
	IF (NOT GIT_FOUND)
		MESSAGE(FATAL_ERROR "Git is required in order to fetch the external project hpm.")
	ENDIF ()

	SET_PROPERTY(DIRECTORY PROPERTY EP_STEP_TARGETS build)

	# Download the hpm library.
	SET(HPM_ROOT ${CMAKE_CURRENT_BINARY_DIR}/deps/hpm)
	SET(HPM_LIB_DIR ${HPM_ROOT}/lib)
	SET(HPM_INCLUDE_DIR ${HPM_ROOT}/include)
	ExternalProject_Add(hpm-external
			URL ${PROJECT_SOURCE_DIR}/extern/hpm
			SOURCE_DIR ${HPM_ROOT}/src/hpm
			BINARY_DIR ${HPM_ROOT}/src/hpm-build
			INSTALL_DIR ${HPM_ROOT}
			CMAKE_ARGS -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR> -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DBUILD_TEST=OFF
			STEP_TARGETS build
			COMMENT "Building Hpm."
			LOG_DOWNLOAD ON)
	# Include HPM headers.
	ADD_LIBRARY(hpm SHARED IMPORTED)
	ADD_DEPENDENCIES(hpm hpm-external)
	SET_TARGET_PROPERTIES(hpm PROPERTIES
			IMPORTED_LOCATION ${HPM_LIB_DIR}/libhpm.so
			INTERFACE_LINK_LIBRARIES ${HPM_LIB_DIR}/libhpm.so
				INTERFACE_INCLUDE_DIRECTORIES ${PROJECT_SOURCE_DIR}/extern/hpm/include)
	SET(HPM_INCLUDE_DIRS "${PROJECT_SOURCE_DIR}/extern/hpm/include")
ENDIF ()

# Source files.
FILE (GLOB headers ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
FILE (GLOB jnisrc ${CMAKE_CURRENT_SOURCE_DIR}/src/*.c )

# Add library targets and linking targets
ADD_LIBRARY(hpmjni ${jnisrc} ${headers})
TARGET_LINK_LIBRARIES(hpmjni PRIVATE jhpm-native hpm ${JNI_LIBRARIES})
TARGET_INCLUDE_DIRECTORIES(hpmjni PRIVATE PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include ${JNI_INCLUDE_DIRS})
IF (BUILD_WITH_EXTERNAL_PROJECT)
	ADD_DEPENDENCIES(hpmjni hpm-external jhpm)
	TARGET_INCLUDE_DIRECTORIES(hpmjni PRIVATE ${HPM_INCLUDE_DIRS})
ELSE()
	ADD_DEPENDENCIES(hpmjni jhpm hpm-external)
ENDIF ()

# Install hpmjni to system.
INSTALL(TARGETS hpmjni DESTINATION lib)